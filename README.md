# Генератор PL\SQL кода  
Генерация пакетных инетрфейсов для работы с таблицами: проверка типов данных, CRUD, exists, mapper функции - всё то, что должно происходить на стороне backend-а, но в силу непреодолимых обстоятельств происходит на стороне субд (активный сервер). 
А потому возникает необходимость в создании repo и service слоев с нормальной генерацией и обработкой ошибок. 
А так как большая часть кода для большей части таблиц однообразна - то вместо того чтобы ручками писать всё это - лучше нагенрировать всё это одной кнопкой, и то что получилось немного допилить (опять же - не для всего, а для большей части, а остальное только ручками). 
# Входные данные 
На вход подается JSON структура с описанием пакетов. В каждом пакете указываются таблицы с перечнем интерфейсных функций, которые будут созданы в этом пакете. Так же есть возможность указать сервисные пакеты в которых будет созданы аналогичные функции но с другими входными параметрами. 
#  Интерфейсные фунции, сервисные, API RESTful 
По сути это @Repository и @Service слой. В первом случае идёт работа с объектами, во втором случае идёт работа функционалом (бизнес-функциями). И бизнес-функции работают уже с объектами через их интерфейс. По сути получается что есть сервисная функция, на вход которой подается некоторый набор данных, например, данные по договору заключенному с клиентом: фио, дата начала действия договора, оборудование сдаваемое в аренду, и авансовый платёж за месяц вперёд. Т.е. по сути тут идёт работа с 4-мя объектами, ноя для бизнеса - это всё одна сущность. Тепер когда переданы все необходимые параметры, в сервисной функции начинается работа с объектами - данные по клиенту мэпятся в объект "Клиент", по оборудованию в объект "Оборудование", и так далее, с испольванием соответствующих интерфейсных функций. После того как были получены объекты (через mapping), с ними уже можно проводить какие то операции - добавлени, изменение, удаление, поиск, и прочие функциии. 
И третьим слоем можно добавить сюда REST функции - которые должны правильно разобрать входящие данные: header параметры, request  body (который может быть xml, json, plain, csv, html, и т.д), и эти данные правильно передать в сервисные функции - в идеале получается что одна REST функция = одна сервисная функция. Т.е. бизнес-логики тут быть не должно. 
# Уровень валидации данных 
Один из вопросов - на каком уровне должна происходить валидация данных: REST, Service, Repository? 
Получается что на REST должен проверяться формат входящих данных - если указан JSON, то данные должны быть форматированы как JSON и соответсттвующим образом разбираться. Если XML то должна быть соответствующая XSD схема (в идеале) по которой сможем проверить что переданные данные соответствую заанному формату. С остальными форматами аналогично.

После, полученные данные должны корректно передаться в вызываемую сервисную функцию. На сервисном уровне сии параметры должны правильно конвертироваться с объекты, и валидироваться должны результаты выполнения действий с объектами - т.е. валидация данных на соответствие их заданым бизнес требованиям. 

На уровне репозитория, валидация состоит в том чтобы входные данные соответствовали заданным диапазонам: рамерность, допустимые значения (например, перечислимый тип, число, not null, и т.д.). 

# Сруктура входных данных
Ниже представлена структура в YAML формате - ибо так удобнее. Для того чтобы сии данные могли использоваться к генераторе кода - надо его предварительно конвертировать в JSON формат (сейчас таких онлайн ресурсов полно), ещё желательно сжать его (таких компрессоров\минификаторов JSON кода так же полно онлайн). Посе полученные данные можно будет использовать в генераторе. 

Итак формат: массив пакетов - можно например несколько логиски объединённых таблицы засунуть в один пакет. А можно и в несколько - потому и массив, чтобы не мучиться с кучей вызовов разных файлов - написал всё в одном и радуйся. 

    - 
      package: "Contracts_p" # Название интерфейсного пакета [Обязательное]
      prefix: "CONTR"        # Группа \ проект -упрощает отлов ошибок, и для выделения группы сообщений [Обязательное]
      schema: "core"         # схема БД  в которой будет создан сей пакет [Обязательное] 
      grants:  # Обхекты \ субъекты, что должны получить права на вполнение сего пакета (grant execute). [Необязательное]. 
        - IVANOV  # Название схемы или пользователя или иного другого объекта 
        - PETROV
      synonyms:  # В каких схемах БД надо создать синонимы для сохдаваемого пакета. Необязательное. 
        - IVANOV
        - PETROV
      # servicePackage - название сервисного пакета. Необзательное поле, но если указать, то по умолчанию по всем функциямя, 
      # у которых не будет явно задан сервисные пакет, будет создана аналогичная функция в сервисном пакете.
      servicePackage: "service.service_p" 
      tables:  # Список таблиц для которых будут сгенерированы репозитории. [Массив][Обязательное]. 
        - # Интейрфейсных функций таблицы можно укзать отдельный исервисный пакет. 
          servicePackage: "crm.crm_api" [Небязательное]
          name: "xdb.app_users_and_roles"  # Schema.Table  [Обязательное]
          mapper: "contracts_mapper" # Маппер [Небязательное] 
          shortname: "appUR" # Короткое имя таблицы - исполуется для сокраения названия функций, и названий переменных.
          primaykey: "id"    # PrimaryKey поле - если только оно одно [Необязательное] 
          sequence: "contracts_seq" # Название сиквенции для ключевого поля [Обязательное]
          defaultfuncs: # Набор стандартных функций. [Массив][Необязательное]
            - type: "add"                   # Добавленик [Обязательное]
              name: ""                      # Название процедуры [Необязательное]. Аналогично для остальных функций.
              servicePackage: ""            # Сервисный пакет [Необязательное]. Аналогично для остальных функций.
              options: "log,raise,check"    # Опции. По умолчанию [Raise]. [Необязательное]. Аналогично для остальных 
            - type: "update"                # Изменение 
            - type: "delete"                # Удаление 
            - type: "findById"              # Найти по Первичному ключу (если он одиночный)
            - type: "findByUnique"          # Набор функций поиска по уникальным ключам
            - type: "findAllByFk"           # Набор Pipelined функция поиска всех записей по внешним ключам 
            - type: "findFirstByFK"         # Набор функци поиска первого значения по внешним ключам 
            - type: "existsById"            # Проверка на существование записи по первичному ключу (не составному)
            - type: "existsByUnique"        # Набор функций проверки существования значений по уникальным ключам 
            - type: "existsByFK"            # Проверка наличия значения по внешним ключам 
            
          customfuncs: # Кастомные функции - по сути каждую дефолтную функцию можно создать здесь (Пока в разработке)
            - type: "findByNameAndSernameOrderByBirthday" # По сути получается аналог JPA, только на PL\SQL  
              name: "findBy_name"
              serviceName: "crm.crm_api.crm_add_contract"
              fields: # Список изменяемых (add, update), или возвращаемых полей (find)
                - All   # %rowtype 
                - id    
                - name
                - fio
                - etc
