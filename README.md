# Генератор PL\SQL кода  
Генерация пакетных инетрфейсов для работы с таблицами: проверка типов данных, CRUD, exists, mapper функции - всё то, что должно происходить на стороне backend-а, но в силу непреодолимых обстоятельств происходит на стороне субд (активный сервер). 
А потому возникает необходимость в создании repo и service слоев с нормальной генерацией и обработкой ошибок. 
А так как большая часть кода для большей части таблиц однообразна - то вместо того чтобы ручками писать всё это - лучше нагенрировать всё это одной кнопкой, и то что получилось немного допилить (опять же - не для всего, а для большей части, а остальное только ручками). 
# Входные данные 
На вход подается JSON структура с описанием пакетов. В каждом пакете указываются таблицы с перечнем интерфейсных функций, которые будут созданы в этом пакете. Так же есть возможность указать сервисные пакеты в которых будет созданы аналогичные функции но с другими входными параметрами. 
#  Интерфейсные фунции, сервисные, API RESTful 
По сути это @Repository и @Service слой. В первом случае идёт работа с объектами, во втором случае идёт работа функционалом (бизнес-функциями). И бизнес-функции работают уже с объектами через их интерфейс. По сути получается что есть сервисная функция, на вход которой подается некоторый набор данных, например, данные по договору заключенному с клиентом: фио, дата начала действия договора, оборудование сдаваемое в аренду, и авансовый платёж за месяц вперёд. Т.е. по сути тут идёт работа с 4-мя объектами, ноя для бизнеса - это всё одна сущность. Тепер когда переданы все необходимые параметры, в сервисной функции начинается работа с объектами - данные по клиенту мэпятся в объект "Клиент", по оборудованию в объект "Оборудование", и так далее, с испольванием соответствующих интерфейсных функций. После того как были получены объекты (через mapping), с ними уже можно проводить какие то операции - добавлени, изменение, удаление, поиск, и прочие функциии. 
И третьим слоем можно добавить сюда REST функции - которые должны правильно разобрать входящие данные: header параметры, request  body (который может быть xml, json, plain, csv, html, и т.д), и эти данные правильно передать в сервисные функции - в идеале получается что одна REST функция = одна сервисная функция. Т.е. бизнес-логики тут быть не должно. 
# Уровень валидации данных 
Один из вопросов - на каком уровне должна происходить валидация данных: REST, Service, Repository? 
Получается что на REST должен проверяться формат входящих данных - если указан JSON, то данные должны быть форматированы как JSON и соответсттвующим образом разбираться. Если XML то должна быть соответствующая XSD схема (в идеале) по которой сможем проверить что переданные данные соответствую заанному формату. С остальными форматами аналогично.

После, полученные данные должны корректно передаться в вызываемую сервисную функцию. На сервисном уровне сии параметры должны правильно конвертироваться с объекты, и валидироваться должны результаты выполнения действий с объектами - т.е. валидация данных на соответствие их заданым бизнес требованиям. 

На уровне репозитория, валидация состоит в том чтобы входные данные соответствовали заданным диапазонам: рамерность, допустимые значения (например, перечислимый тип, число, not null, и т.д.). 

# Сруктура входных данных
Ниже представлена структура в YAML формате - ибо так удобнее. Для того чтобы сии данные могли использоваться к генераторе кода - надо его предварительно конвертировать в JSON формат (сейчас таких онлайн ресурсов полно), ещё желательно сжать его (таких компрессоров\минификаторов JSON кода так же полно онлайн). Посе полученные данные можно будет использовать в генераторе. 

Итак формат: массив пакетов - можно например несколько логиски объединённых таблицы засунуть в один пакет. А можно и в несколько - потому и массив, чтобы не мучиться с кучей вызовов разных файлов - написал всё в одном и радуйся. 

    - 
      package: "Contracts_p" # Название интерфейсного пакета [Обязательное]
      prefix: "CONTR"        # Группа \ проект -упрощает отлов ошибок, и для выделения группы сообщений [Обязательное]
      schema: "core"         # схема БД  в которой будет создан сей пакет [Обязательное] 
      grants:  # Обхекты \ субъекты, что должны получить права на вполнение сего пакета (grant execute). [Необязательное]. 
        - IVANOV  # Название схемы или пользователя или иного другого объекта 
        - PETROV
      synonyms:  # В каких схемах БД надо создать синонимы для сохдаваемого пакета. Необязательное. 
        - IVANOV
        - PETROV
      # servicePackage - название сервисного пакета. Необзательное поле, но если указать, то по умолчанию по всем функциямя, 
      # у которых не будет явно задан сервисные пакет, будет создана аналогичная функция в сервисном пакете.
      servicePackage: "service.service_p" 
      tables:  # Список таблиц для которых будут сгенерированы репозитории. [Массив][Обязательное]. 
        - # Интейрфейсных функций таблицы можно укзать отдельный исервисный пакет. 
          servicePackage: "crm.crm_api" [Небязательное]
          name: "xdb.app_users_and_roles"  # Schema.Table  [Обязательное]
        mapper: "contracts_mapper" # Маппер [Небязательное] 
        shortname: "appUR" # Короткое имя таблицы - исполуется для сокраения названия функций, и названий переменных.
        primaykey: "id"    # PrimaryKey поле - если только оно одно [Необязательное] 
        sequence: "contracts_seq" # Название сиквенции для ключевого поля [Обязательное]
        defaultfuncs: # Набор стандартных функций
            - type: "add"
              name: ""
              servicePackage: ""
              options: "log,raise,check"
            - type: "update"
            - type: "delete"
            - type: "findById"
            - type: "findByUnique"
            - type: "findAllByFk"
            - type: "findFirstByFK"
            - type: "existsById"
            - type: "existsByUnique"
            - type: "existsByFK"
        customfuncs: # список создаваемых функий 
          - 
            name: "add_contracts"
            type: "add"  # Базовый набор функций  - Create (add), Read (getRow), Update, Delete - CRUF по сути объединение нескольких - и исключение  
                   # по умолчанию без логировани, с генераторами ошибок и проверкой только изменяемых полей 
            options: # Опции при генерации кода 
              - logNone # не логировать - по умолчанию 
              - logAll  # Логировать действия при вызове функции 
              - logCreate  # Отдельно для каждой процедуры можно задават логирование 
              - logRead  # 
              - logUpdate # 
              - logDelete # 
              - raiseAll  # Добавить генерацию ошибок для всех процедур (с возможностью отмены генерации ошибки) - по умолчанию  
              - raiseCreate # Для каждой отдельно можно задавать генерацию ошибок 
              - raiseUpdate #  asd asd 
              - raiseDelete  # asdasd
              - checkAllFields  # всегда проверять ВСЕ поля при выполнении функции добавления  изменения 
              - checkUpdatedFields # Проверять только те поля - которые изменяеются - По умолчанию 
            names:  # Названия процедур (в порядке в соответствии с аббревиатурой)
              - add_contract  # по умолчанию - add_<имя_таблицы>
              - get_contract  # по умолчанию - add_<имя_таблицы> - возвращает ищет строку по ключевым полям (PK)
              - update_contract  # по умолчанию - add_<имя_таблицы>
              - deleteContract  # по умолчанию - add_<имя_таблицы>
            servicePackage: # сервисный слой - функции которые будут получать на вход параметры, проверять их на значения, и типы данных и вызывать Repository функции 
              - procedure:
                  name: "add_contract"
                  serviceName: "crm.crm_api.crm_add_contract"
                  fields: # поля используемые во входных данных на CRUD функциях - наверное всё же    надо разделить CRUD функции, ибо фигня получается 
                    - All # по умолчанию 
                    - id 
                    - name
                    - fio
                    - etc
          - exists: # Функция проверки существования записи по PK # По умолчанию без логов и поиск по PK и  Uniq 
            options:
              - logError # логировать (none - по умолчанию ) 
              - raiseError # генерация ошибки (с возможностью отключить ломание - pRaise boolean := true)
              - existsByUnique # сгенерировать функции проверки существования значения, но только по уникальным индексам (с такими же параметрами что и для PK)
            names:
              - exists_contract # название функции поиска по PK - по умолчанию exists_<имя_таблицы>
                                # для unique -  exists_<имя_таблицы>_<имя_первого_поля_уникального_индекса>_...
          - finds: # по умолчанию создаются find, findByUnique, findByFK
              - find # поиск всех значений по заданным параметрами - pipelined функция c %rowtype таблицы 
                     # используемые параметры все поля таблицы, и если они null то такие параметры не учитываются в поиске 
              - findByFieldAndOrIsNullNotNull # В общем почти или как в JPA - создание функции поиска по заданным полям
                # поиск по полю, по нему можно дополнительно добавить приставку not null или is null
                # допольнительное условие по другому полю и связка And или Or - т.е. чтобы можно было добавить простую функцию 
                # поиска - понятную по названию и с понятными простыми условиями 
                # по умолчанию findAll (All можно опустить), но можно и findFirst 
              - myFindFunction: # кастомная функция поиска - по сути любая функция которая не может разобраться по заданным правилам 
                - searchField1 # спискок полей по которым надо искать (должны совпадать с названиями полей таблицы, инасе по умоланию varchar2)
              - findByUnique: # функции поиска по уникальным индексам (по аналогии с exists), All\First - по умолчанию название будет findAllBy_field1_field2 ... - но только при ограничении на 30 символов
                - uniqueIndexName: "nameOfThisProcedure" # можно указать уникальный индекс и название функции на основании которой и бует создаваться процедура , но тогда надо будет укзать все остальные такие функции 
              - findByFk # создаются все функции которые с поиском по поям которые являются вторичными ключами 
